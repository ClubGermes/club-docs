# Фоновые задачи и Очереди

> **⚠️ Критично для Legacy:**
> В проекте **отсутствует** надежный брокер очередей (вроде RabbitMQ или Redis) для старого кода. Используются in-memory решения, которые **теряют данные при перезагрузке**.

## 1. Internal Stream (In-Memory Queue)

В сервисе `club-api` реализована самописная очередь задач в оперативной памяти.

*   **Код:** `backend/apps/club-api/app/core/stream.py`
*   **Реализация:** `asyncio.deque` (Python Deque).
*   **Назначение:** Отправка SMS, Email, сообщений в Telegram.

### Риски и Особенности
1.  **Потеря данных:** Если сервис упадет или будет перезапущен (деплой), все задачи в очереди (неотправленные SMS/Email) **исчезнут навсегда**.
2.  **Retry Policy:** Есть встроенный механизм повторов (`retry_error`). Если внешний шлюз (SMS) недоступен, задача возвращается в начало очереди с задержкой.

## 2. PgQueue (Event Bus)

Для реакции на изменения данных в реальном времени используется механизм **PostgreSQL LISTEN/NOTIFY**.

*   **Код:** `backend/apps/club-api/app/core/pgqueue.py`
*   **Канал:** `events`
*   **Принцип работы:**
    1.  SQL-триггер или процедура выполняет `NOTIFY events, payload`.
    2.  Фоновый процесс `PgQueue` получает уведомление.
    3.  Вызывается обработчик (часто это рассылка обновлений через WebSocket).

## Рекомендации для нового кода

При разработке новых сервисов (`club-events`):
*   **НЕ используйте** in-memory очереди для критических задач.
*   Используйте надежные инструменты: **Arq**, **Celery** или **BullMQ** (на базе Redis).
