# Внутреннее устройство Legacy (club-api)

> **⚠️ Важно:** Этот раздел описывает архитектуру старого монолита `club-api`. Новый код должен использовать современные подходы (Tortoise ORM, DI), но для поддержки текущей системы необходимо понимать эти механизмы.

В `club-api` **нет стандартной ORM** (как SQLAlchemy). Вместо этого используется самописная асинхронная обертка над драйвером `asyncpg`.

## 1. Работа с базой данных (`PgBank`)

Весь доступ к БД осуществляется через глобальный объект контекста приложения (обычно доступен как `api` или `request.app`).

**Исходный код:** `backend/apps/club-api/app/core/pg.py`

### Основные методы

Вместо моделей и сессий используются сырые SQL-запросы. Пример типичного обработчика:

```python
async def get_user_data(request):
    # Получение контекста (обычно доступен через request.app)
    api = request.app
    user_id = 100 

    # 1. Получение одной строки (возвращает dict-like Record)
    user = await api.pg.club.fetchrow(
        "SELECT * FROM users WHERE id = $1", 
        user_id
    )

    # 2. Получение списка строк
    events = await api.pg.club.fetch(
        "SELECT * FROM events WHERE active = $1",
        True
    )

    # 3. Получение одного значения
    count = await api.pg.club.fetchval("SELECT count(*) FROM users")

    # 4. Выполнение команды (без возврата данных)
    await api.pg.club.execute(
        "UPDATE users SET active = $1 WHERE id = $2",
        False, user_id
    )
    
    return {"user": user, "count": count}
```

### Особенности `PgBank`
1.  **JSONB:** Автоматически сериализует и десериализует поля типа `jsonb` (используя быстрый `orjson`). Не нужно делать `json.loads()` вручную.
2.  **Timestamps:** Автоматически конвертирует `datetime` в timestamp (int) и обратно.
3.  **Транзакции:** Есть встроенный механизм защиты от зависших транзакций (тайм-аут `MAX_TRANSACTION_TIME`).

---

## 2. Система событий (`PgQueue`)

Система использует механизм **PostgreSQL LISTEN/NOTIFY** для реализации реактивности (отправка уведомлений, обновление кэшей).

**Исходный код:** `backend/apps/club-api/app/core/pgqueue.py`

### Как это работает

1.  **Триггер в БД:** Когда что-то меняется в важных таблицах, триггер (или хранимая процедура) выполняет SQL-команду:
    ```sql
    NOTIFY events, '{"type": "new_registration", "user_id": 123}';
    ```
2.  **Слушатель (`PgQueue`):** При старте приложения запускается фоновая задача, которая подписывается на канал `events` с помощью библиотеки `asyncpg_listen`.
3.  **Обработчик:**
    *   Получает JSON-пейлоад.
    *   Имеет защиту от спама ("debounce"): обрабатывает события не чаще, чем раз в 2 секунды (`sleep(2)`).
    *   Вызывает callback-функцию, которая маршрутизирует событие дальше (например, в WebSocket или Push-сервис).

### Пример использования

Если вы добавляете новую логику уведомлений:
1.  Убедитесь, что БД отправляет `NOTIFY` в канал `events`.
2.  Логика обработки находится в `app/models/notification.py` (или том месте, которое передается как callback при инициализации).

---

## 3. Конфигурация (`.toml`)

В отличие от стандартных `.env` файлов, legacy-сервис использует **TOML-файлы** для конфигурации.

**Расположение:** `backend/apps/club-api/app/config/*.toml`

*   `settings.toml` — основные настройки.
*   `pg.toml` — параметры подключения к базе данных.
*   `info.toml` — метаданные сервиса.

> **Внимание:** Изменение `.env` файла в корне может **не повлиять** на настройки `club-api`, если они жестко прописаны в TOML. Всегда проверяйте содержимое `app/config/`.

---

## 4. Кастомный упаковщик (`Packager`)

Для работы с кэшем в Redis используется нестандартный формат сериализации.

**Исходный код:** `backend/apps/club-api/app/utils/packager.py`

*   **Формат:** Данные хранятся в строках с префиксом типа, например `type:gzip:base64_data`.
*   **Проблема:** Стандартные библиотеки Redis не смогут прочитать эти данные.
*   **Решение:** Если вам нужно читать кэш legacy-сервиса из нового кода, придется портировать логику распаковки из `packager.py`.

---

## 5. Ограничения WebSockets

WebSocket-сервер в `club-api` реализован с серьезным архитектурным ограничением.

**Исходный код:** `backend/apps/club-api/app/core/api.py`

*   **Stateful:** Список активных подключений хранится в оперативной памяти процесса Python (`self.store['websockets']`).
*   **Не масштабируется:** Если запустить несколько экземпляров `club-api` (например, в Kubernetes), они **не будут знать** о сокетах друг друга.
    *   *Сценарий сбоя:* Пользователь А подключен к Инстансу 1. Триггер срабатывает в Инстансе 2. Инстанс 2 пытается отправить уведомление пользователю А, но не находит его в своей памяти. Уведомление не доставляется.
*   **Решение:** Для масштабирования необходимо внедрять Redis Pub/Sub адаптер или переходить на Centrifugo.
